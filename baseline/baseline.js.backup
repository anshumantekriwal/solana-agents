import { PrivyClient } from "@privy-io/server-auth";
import {
    PublicKey,
    SystemProgram,
    VersionedTransaction,
    TransactionMessage,
    Connection,
    clusterApiUrl,
  } from '@solana/web3.js';
import { TOKEN_PROGRAM_ID } from '@solana/spl-token';
import fetch from 'node-fetch';
import dotenv from "dotenv";

dotenv.config();

// =============================
// ======= GLOBAL INSTANCES =======
// =============================

const privy = new PrivyClient(process.env.PRIVY_APP_ID, process.env.PRIVY_APP_SECRET);
const connection = new Connection(clusterApiUrl('mainnet-beta'), 'confirmed');

// Global cache for Jupiter tokens (shared across all operations)
let jupiterTokensCache = null;
let jupiterTokensCacheTime = 0;
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

// =============================
// ======= Wallet Creation =======
// =============================

const ownerAddress = "5NGqPDeoEfpxwq8bKHkMaSyLXDeR7YmsxSyMbXA5yKSQ";

async function createWallet(ownerAddress) {
    const walletConfig = { chainType: "solana" };
    if (ownerAddress) walletConfig.ownerAddress = ownerAddress;
    
    const wallet = await privy.walletApi.createWallet(walletConfig);
        return { walletId: wallet.id, walletAddress: wallet.address };
}

async function getWallet(walletId) {
    const wallet = await privy.walletApi.getWallet({ id: walletId });
    return { walletId: wallet.id, walletAddress: wallet.address };
}

async function getOrCreateWallet(ownerAddress) {
    if (process.env.WALLET_ID) {
        console.log("Wallet ID found in environment");
        return await getWallet(process.env.WALLET_ID);
    } else {
        console.log("Creating new wallet");
        return await createWallet(ownerAddress);
    }
}

// =============================
// ======= SHARED UTILITIES =======
// =============================

// Optimized Jupiter token fetcher (shared across all functions)
async function getJupiterTokens() {
    const now = Date.now();
    if (!jupiterTokensCache || (now - jupiterTokensCacheTime) > CACHE_DURATION) {
      try {
            const response = await fetch('https://token.jup.ag/all', { timeout: 5000 });
        if (response.ok) {
          jupiterTokensCache = await response.json();
          jupiterTokensCacheTime = now;
        }
        } catch (error) {
            console.log('Failed to update Jupiter cache:', error.message);
            if (!jupiterTokensCache) throw new Error('Unable to fetch token list from Jupiter API');
        }
    }
    return jupiterTokensCache;
}

// =============================
// ======= Balance Operations =======
// =============================

async function getTokenMetadata(mintAddress) {
    try {
        const tokens = await getJupiterTokens();
        const token = tokens.find(t => t.address === mintAddress);
      
      if (token) {
        return {
          name: token.name || 'Unknown',
          symbol: token.symbol || 'Unknown',
          decimals: token.decimals,
          logoURI: token.logoURI || ''
        };
    }
    
    // Fallback: Try Solana RPC metadata
    const mintPublicKey = new PublicKey(mintAddress);
    try {
      const accountInfo = await connection.getAccountInfo(mintPublicKey);
      if (accountInfo) {
        return {
          name: `Token ${mintAddress.slice(0, 8)}...`,
          symbol: 'SPL',
          decimals: accountInfo.data[44] || 0,
          logoURI: ''
        };
      }
    } catch (rpcError) {
      console.log('RPC metadata fetch failed, using defaults');
    }
    
        // Final fallback
    return {
      name: `Token ${mintAddress.slice(0, 8)}...`,
      symbol: 'SPL',
      decimals: 0,
      logoURI: ''
    };
  } catch (error) {
    console.error('Error fetching token metadata:', error);
    return {
      name: `Token ${mintAddress.slice(0, 8)}...`,
      symbol: 'SPL',
      decimals: 0,
      logoURI: ''
    };
  }
}
  
  async function getBalances(walletAddress) {
    const publicKey = new PublicKey(walletAddress);
    
    try {
      // Fetch native SOL balance and token accounts in parallel
      const [solBalance, tokenAccounts] = await Promise.all([
        connection.getBalance(publicKey),
            connection.getParsedTokenAccountsByOwner(publicKey, { programId: TOKEN_PROGRAM_ID })
      ]);
      
      // Process token balances
      const tokenBalances = await Promise.all(
        tokenAccounts.value.map(async (account) => {
          const { tokenAmount, mint } = account.account.data.parsed.info;
          
          try {
            const metadata = await getTokenMetadata(mint);
            return {
              mint,
              tokenAmount: tokenAmount.amount,
              decimals: tokenAmount.decimals,
              uiAmount: tokenAmount.uiAmount,
              name: metadata.name,
              symbol: metadata.symbol,
              logoURI: metadata.logoURI
            };
          } catch (error) {
            console.log(`Metadata fetch failed for ${mint}:`, error.message);
            return {
              mint,
              tokenAmount: tokenAmount.amount,
              decimals: tokenAmount.decimals,
              uiAmount: tokenAmount.uiAmount,
              name: `Token ${mint.slice(0, 8)}...`,
              symbol: 'SPL',
              logoURI: ''
            };
          }
        })
      );
      
        // SOL balance formatted
      const solBalanceFormatted = {
        mint: 'SOL',
        tokenAmount: solBalance.toString(),
        decimals: 9,
        uiAmount: solBalance / 1e9,
        name: 'Solana',
        symbol: 'SOL',
        logoURI: 'https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/So11111111111111111111111111111111111111112/logo.png'
      };

        return { allBalances: [solBalanceFormatted, ...tokenBalances] };
    } catch (error) {
      console.error('Error fetching balances:', error);
      throw error;
    }
  }

// =============================
// ======= Transfer Operations =======
// =============================

async function transfer(fromWalletId, toAddress, amountInSol, fromWalletAddress) {
  try {
        const fromWalletPublicKey = new PublicKey(fromWalletAddress);
    const toWalletPublicKey = new PublicKey(toAddress);
    const amountInLamports = amountInSol * 1e9;
    
    console.log(`Transfer amount: ${amountInLamports} lamports (${amountInSol} SOL)`);
    
    const instruction = SystemProgram.transfer({
      fromPubkey: fromWalletPublicKey,
      toPubkey: toWalletPublicKey,
      lamports: amountInLamports,
    });
    
    const message = new TransactionMessage({
      payerKey: fromWalletPublicKey,
      instructions: [instruction],
      recentBlockhash: "11111111111111111111111111111111",
    });
    
    const transaction = new VersionedTransaction(message.compileToV0Message());
    
    const { hash } = await privy.walletApi.solana.signAndSendTransaction({
      walletId: fromWalletId,
            caip2: 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',
      transaction: transaction,
    });
    
    console.log(`Transfer transaction sent: hash=${hash}`);
    return { success: true, hash };
  } catch (error) {
    console.error('Transfer failed:', error);
    return { success: false, error: error.message };
  }
}

// =============================
// ======= Swap Operations =======
// =============================

async function swap(fromTokenSymbol, toTokenSymbol, fromAmount, walletAddress) {
  try {
        const tokens = await getJupiterTokens();
    
    // Find tokens by symbol
    const fromTokenInfo = tokens.find(t => 
            t.symbol && t.symbol.toUpperCase() === fromTokenSymbol.toUpperCase()
    );
    const toTokenInfo = tokens.find(t => 
            t.symbol && t.symbol.toUpperCase() === toTokenSymbol.toUpperCase()
        );
        
        if (!fromTokenInfo || !toTokenInfo) {
            throw new Error(`Token not found: ${fromTokenSymbol} or ${toTokenSymbol}`);
    }
    
    const fromToken = fromTokenInfo.address;
    const toToken = toTokenInfo.address;
    const fromTokenDecimals = fromTokenInfo.decimals;
    
    console.log(`Swapping ${fromAmount} ${fromTokenSymbol} to ${toTokenSymbol}`);
    console.log(`From token: ${fromToken} (${fromTokenDecimals} decimals)`);
    console.log(`To token: ${toToken}`);
    
    // Convert human-readable amount to raw amount
    const rawAmount = Math.floor(fromAmount * Math.pow(10, fromTokenDecimals));
    
    console.log(`Converting ${fromAmount} ${fromTokenSymbol} (${fromTokenDecimals} decimals) to ${rawAmount} raw units`);
    
    const url = `https://li.quest/v1/quote?fromChain=SOL&toChain=SOL&fromToken=${fromToken}&toToken=${toToken}&fromAddress=${walletAddress}&toAddress=${walletAddress}&fromAmount=${rawAmount}`;
    
    const quoteResponse = await fetch(url, {
      method: 'GET',
            headers: { 'accept': 'application/json' }
    });
    
    if (!quoteResponse.ok) {
      throw new Error(`HTTP error! status: ${quoteResponse.status}`);
    }
    
    const quote = await quoteResponse.json();
    return { success: true, quote };
  } catch (error) {
    console.error('Failed to get swap quote:', error);
    return { success: false, error: error.message };
  }
}

// =============================
// ======= Execute Swap (Optimized) =======
// =============================

async function executeSwapJupiter(walletId, fromTokenSymbol, toTokenSymbol, fromAmount, walletAddress, options = {}) {
  try {
    const startTime = Date.now();
    console.log(`🚀 Optimized Jupiter swap: ${fromAmount} ${fromTokenSymbol} → ${toTokenSymbol}`);
    
    // Default options with smart defaults
    const {
      slippageBps = 100, // 1% slippage (more reasonable than 0.5%)
      priorityFee = 'auto', // Let Jupiter optimize
      maxRetries = 3,
      confirmTransaction = true
    } = options;
    
    // Use shared Jupiter token cache
    const tokens = await getJupiterTokens();
    
    const fromTokenInfo = tokens.find(t => 
        t.symbol && t.symbol.toUpperCase() === fromTokenSymbol.toUpperCase()
    );
    const toTokenInfo = tokens.find(t => 
        t.symbol && t.symbol.toUpperCase() === toTokenSymbol.toUpperCase()
    );
    
    if (!fromTokenInfo || !toTokenInfo) {
        throw new Error(`Token not found: ${fromTokenSymbol} or ${toTokenSymbol}`);
    }
    
    const fromToken = fromTokenInfo.address;
    const toToken = toTokenInfo.address;
    const fromTokenDecimals = fromTokenInfo.decimals;
    
    // Convert with proper precision handling
    const rawAmount = BigInt(Math.floor(fromAmount * Math.pow(10, fromTokenDecimals)));
    
    console.log(`📊 Token details: ${fromToken} (${fromTokenDecimals} decimals) → ${toToken}`);
    
    // Optimized quote request with better parameters
    const quoteParams = new URLSearchParams({
      inputMint: fromToken,
      outputMint: toToken,
      amount: rawAmount.toString(),
      slippageBps: slippageBps.toString(),
      onlyDirectRoutes: 'false', // Allow multi-hop for better rates
      asLegacyTransaction: 'false', // Use versioned transactions
      maxAccounts: '64', // Optimize for compute units
      minimizeSlippage: 'true'
    });
    
    // Get quote with timeout and retry logic
    let quoteData;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const quoteResponse = await fetch(`https://quote-api.jup.ag/v6/quote?${quoteParams}`, {
          timeout: 10000 // 10 second timeout
        });
        
        if (!quoteResponse.ok) {
          const errorText = await quoteResponse.text();
          throw new Error(`Quote API error ${quoteResponse.status}: ${errorText}`);
        }
        
        quoteData = await quoteResponse.json();
        
        if (!quoteData.outAmount || quoteData.outAmount === '0') {
          throw new Error('No valid route found for this swap');
        }
        
        break; // Success, exit retry loop
      } catch (error) {
        console.log(`⚠️  Quote attempt ${attempt}/${maxRetries} failed: ${error.message}`);
        if (attempt === maxRetries) throw error;
        await new Promise(resolve => setTimeout(resolve, 1000 * attempt)); // Exponential backoff
      }
    }
    
    // Calculate expected output in human-readable format
    const expectedOutput = parseFloat(quoteData.outAmount) / Math.pow(10, toTokenInfo.decimals);
    const priceImpact = quoteData.priceImpactPct || 0;
    
    console.log(`💰 Expected output: ${expectedOutput.toFixed(6)} ${toTokenSymbol} (Impact: ${priceImpact}%)`);
    
    // Optimized swap transaction request
    const swapPayload = {
      quoteResponse: quoteData,
      userPublicKey: walletAddress,
      wrapAndUnwrapSol: true,
      dynamicComputeUnitLimit: true,
      prioritizationFeeLamports: priorityFee,
      dynamicSlippage: { // Enable dynamic slippage for better execution
        maxBps: Math.max(slippageBps, 300) // At least 3% max
      }
    };
    
    // Get swap transaction with retry logic
    let swapData;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const swapResponse = await fetch('https://quote-api.jup.ag/v6/swap', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          },
          body: JSON.stringify(swapPayload),
          timeout: 15000 // 15 second timeout
        });
        
        if (!swapResponse.ok) {
          const errorText = await swapResponse.text();
          throw new Error(`Swap API error ${swapResponse.status}: ${errorText}`);
        }
        
        swapData = await swapResponse.json();
        
        if (!swapData.swapTransaction) {
          throw new Error('No swap transaction received from Jupiter');
        }
        
        break; // Success, exit retry loop
      } catch (error) {
        console.log(`⚠️  Swap transaction attempt ${attempt}/${maxRetries} failed: ${error.message}`);
        if (attempt === maxRetries) throw error;
        await new Promise(resolve => setTimeout(resolve, 1000 * attempt)); // Exponential backoff
      }
    }
    
    console.log(`⚡ Transaction prepared in ${Date.now() - startTime}ms`);
    
    // Deserialize and send transaction
    const transactionBuffer = Buffer.from(swapData.swapTransaction, 'base64');
    const transaction = VersionedTransaction.deserialize(transactionBuffer);
    
    console.log(`📤 Signing and sending transaction...`);
    
    // Sign and send with Privy
    const { hash } = await privy.walletApi.solana.signAndSendTransaction({
      walletId: walletId,
      caip2: 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',
      transaction: transaction,
    });
    
    console.log(`✅ Transaction sent: ${hash}`);
    
    // Optional: Wait for confirmation
    if (confirmTransaction) {
        console.log(`⏳ Confirming transaction...`);
        try {
            const confirmation = await connection.confirmTransaction(hash, 'confirmed');
            
            if (confirmation.value.err) {
                console.log(`❌ Transaction failed: ${confirmation.value.err}`);
            } else {
                console.log(`✅ Transaction confirmed!`);
            }
        } catch (confirmError) {
            console.log(`⚠️  Confirmation check failed: ${confirmError.message}`);
            // Don't fail the whole operation for confirmation issues
        }
    }
    
    const totalTime = Date.now() - startTime;
    console.log(`🎉 Swap completed in ${totalTime}ms`);
    
    return { 
      success: true, 
      hash,
      fromAmount: rawAmount.toString(),
      estimatedToAmount: quoteData.outAmount,
      actualOutputAmount: expectedOutput,
      fromToken: fromTokenSymbol,
      toToken: toTokenSymbol,
      priceImpact: priceImpact,
      executionTime: totalTime,
      route: quoteData.routePlan || []
    };
    
  } catch (error) {
    console.error(`❌ Jupiter swap failed: ${error.message}`);
    
    // Enhanced error reporting
    let errorCategory = 'unknown';
    if (error.message.includes('insufficient')) errorCategory = 'insufficient_funds';
    else if (error.message.includes('slippage')) errorCategory = 'slippage_exceeded';
    else if (error.message.includes('timeout')) errorCategory = 'timeout';
    else if (error.message.includes('route')) errorCategory = 'no_route';
    
    return { 
      success: false, 
      error: error.message,
      errorCategory,
      timestamp: new Date().toISOString()
    };
  }
}


// =============================
// ======= Market Data =======
// =============================  

const MOBULA_BASE_URL = 'https://explorer-api.mobula.io/api/1/market/data';

async function marketData(symbol) {
  try {
        const url = `${MOBULA_BASE_URL}?shouldFetchPriceChange=24h&symbol=${symbol.toUpperCase()}`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': process.env.MOBULA_API_KEY
      }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    return data['data'];
    } catch (error) {
        console.error('Failed to get market data:', error); 
        return { success: false, error: error.message };
    }
}
    
async function price(symbol) {
    try {
        const data = await marketData(symbol);
        return data.success === false ? data : data.price;
  } catch (error) {
    console.error('Failed to get price:', error); 
    return { success: false, error: error.message };
  }
}


// =============================
// ======= Token Mint Address =======
// =============================

async function getTokenMintAddress(symbol) {
    try {
        const tokens = await getJupiterTokens();
        
        // Find token by symbol (case-insensitive)
        const token = tokens.find(t => 
            t.symbol && t.symbol.toUpperCase() === symbol.toUpperCase()
        );
        
        if (!token) {
            throw new Error(`Token with symbol '${symbol}' not found`);
        }
        
        return {
            success: true,
            mintAddress: token.address,
            tokenInfo: {
                name: token.name,
                symbol: token.symbol,
                decimals: token.decimals,
                logoURI: token.logoURI || ''
            }
        };
  } catch (error) {
        console.error('Failed to get token mint address:', error);
        return { 
            success: false, 
            error: error.message 
        };
    }
}

// =============================
// ======= Twitter Data =======
// =============================

async function twitter(user, lastTweets = []) {
  try {
    const url = `https://twitter-agent-kz2u.onrender.com/api/tweets/${user}?count=5`;
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': process.env.TWITTER_API_KEY
      }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
        const currentTweets = data.data || [];
    
    // Compare current tweets with inputted lastTweets
    let hasNewTweet = false;
    let newTweet = null;
    
    if (lastTweets.length === 0) {
      return { hasNewTweet: false, newTweet: null, currentTweets };
    }
    
    // Check if there are new tweets by comparing tweet IDs or content
    for (const currentTweet of currentTweets) {
      const isNewTweet = !lastTweets.some(lastTweet => 
        (currentTweet.id && lastTweet.id && currentTweet.id === lastTweet.id) ||
        (currentTweet.text && lastTweet.text && currentTweet.text === lastTweet.text)
      );
      
      if (isNewTweet) {
        hasNewTweet = true;
        newTweet = currentTweet;
                break;
      }
    }
    
    return { 
      hasNewTweet, 
      newTweet, 
      currentTweets,
      username: user 
    };
  } catch (error) {
    console.error('Failed to fetch tweets:', error);
    return { 
      hasNewTweet: false, 
      newTweet: null, 
      error: error.message,
      username: user 
    };
  }
}


// =============================
// ======= Account Utilities =======
// =============================

async function checkTokenAccountExists(walletAddress, mintAddress) {
    try {
        const publicKey = new PublicKey(walletAddress);
        const mintPublicKey = new PublicKey(mintAddress);
        
        const tokenAccounts = await connection.getParsedTokenAccountsByOwner(publicKey, {
            mint: mintPublicKey
        });
        
        return tokenAccounts.value.length > 0;
    } catch (error) {
        console.error('Error checking token account:', error);
        return false;
    }
}

// =============================
// ======= Scheduling System =======
// =============================

// Global scheduler state
const schedulerState = {
  activeSchedules: new Map(),
  nextScheduleId: 1
};

/**
 * Parse scheduling configuration from user input
 * @param {string} scheduleType - 'interval' or 'times'
 * @param {string} scheduleValue - The schedule specification
 * @returns {Object} Parsed schedule configuration
 */
function parseScheduleConfig(scheduleType, scheduleValue) {
  const config = { type: scheduleType, isValid: false };
  
  try {
    if (scheduleType === 'interval') {
      // Parse interval format: "5m", "1h", "30s", "2h30m"
      const intervalRegex = /^(?:(\d+)h)?(?:(\d+)m)?(?:(\d+)s)?$/i;
      const match = scheduleValue.toLowerCase().match(intervalRegex);
      
      if (match) {
        const hours = parseInt(match[1]) || 0;
        const minutes = parseInt(match[2]) || 0;
        const seconds = parseInt(match[3]) || 0;
        
        const totalMs = (hours * 3600 + minutes * 60 + seconds) * 1000;
        
        if (totalMs > 0) {
          config.intervalMs = totalMs;
          config.isValid = true;
          config.description = `Every ${scheduleValue}`;
        }
      }
    } else if (scheduleType === 'times') {
      // Parse time format: "09:30", "14:00,18:30", "9:30 AM,2:30 PM"
      const times = scheduleValue.split(',').map(t => t.trim());
      const parsedTimes = [];
      
      for (const timeStr of times) {
        const time = parseTimeString(timeStr);
        if (time !== null) {
          parsedTimes.push(time);
        }
      }
      
      if (parsedTimes.length > 0) {
        config.times = parsedTimes.sort((a, b) => a.hour * 60 + a.minute - (b.hour * 60 + b.minute));
        config.isValid = true;
        config.description = `At ${parsedTimes.map(t => `${t.hour.toString().padStart(2, '0')}:${t.minute.toString().padStart(2, '0')}`).join(', ')}`;
      }
    }
  } catch (error) {
    console.error('Error parsing schedule config:', error);
  }
  
  return config;
}

/**
 * Parse time string to hour/minute object
 * @param {string} timeStr - Time string like "09:30", "9:30 AM", "14:00"
 * @returns {Object|null} {hour, minute} or null if invalid
 */
function parseTimeString(timeStr) {
  try {
    // Handle AM/PM format
    const ampmRegex = /^(\d{1,2}):(\d{2})\s*(AM|PM)$/i;
    const ampmMatch = timeStr.match(ampmRegex);
    
    if (ampmMatch) {
      let hour = parseInt(ampmMatch[1]);
      const minute = parseInt(ampmMatch[2]);
      const period = ampmMatch[3].toUpperCase();
      
      if (period === 'PM' && hour !== 12) hour += 12;
      if (period === 'AM' && hour === 12) hour = 0;
      
      if (hour >= 0 && hour <= 23 && minute >= 0 && minute <= 59) {
        return { hour, minute };
      }
    }
    
    // Handle 24-hour format
    const timeRegex = /^(\d{1,2}):(\d{2})$/;
    const timeMatch = timeStr.match(timeRegex);
    
    if (timeMatch) {
      const hour = parseInt(timeMatch[1]);
      const minute = parseInt(timeMatch[2]);
      
      if (hour >= 0 && hour <= 23 && minute >= 0 && minute <= 59) {
        return { hour, minute };
      }
    }
  } catch (error) {
    console.error('Error parsing time string:', error);
  }
  
  return null;
}

/**
 * Calculate next execution time for time-based schedule
 * @param {Array} times - Array of {hour, minute} objects
 * @returns {Date} Next execution date
 */
function getNextExecutionTime(times) {
  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  
  // Find next time today
  for (const time of times) {
    const executionTime = new Date(today.getTime() + time.hour * 3600000 + time.minute * 60000);
    if (executionTime > now) {
      return executionTime;
    }
  }
  
  // If no time today, use first time tomorrow
  const tomorrow = new Date(today.getTime() + 24 * 3600000);
  const firstTime = times[0];
  return new Date(tomorrow.getTime() + firstTime.hour * 3600000 + firstTime.minute * 60000);
}

/**
 * Start scheduled execution of baseline function
 * @param {Object} params - Baseline function parameters
 * @param {Object} scheduleConfig - Schedule configuration
 * @returns {string} Schedule ID for management
 */
function startScheduledExecution(params, scheduleConfig) {
  const scheduleId = `schedule_${schedulerState.nextScheduleId++}`;
  
  console.log(`🕒 Starting scheduled execution: ${scheduleConfig.description}`);
  console.log(`📋 Schedule ID: ${scheduleId}`);
  
  let timeoutId;
  let intervalId;
  
  const executeFunction = async () => {
    try {
      console.log(`\n⏰ [${new Date().toISOString()}] Executing scheduled baseline function...`);
      const result = await baselineFunctionCore(params.ownerAddress, params.fromToken, params.toToken, params.amount);
      if (result.success) {
        console.log(`✅ Scheduled execution completed at ${new Date().toISOString()}\n`);
      } else {
        console.log(`⚠️ Scheduled execution completed with issues: ${result.error}`);
      }
    } catch (error) {
      console.error(`❌ Scheduled execution failed at ${new Date().toISOString()}:`, error);
    }
  };
  
  if (scheduleConfig.type === 'interval') {
    // Interval-based scheduling
    console.log(`⏱️  Will execute every ${scheduleConfig.intervalMs}ms`);
    
    // Execute immediately, then set interval
    executeFunction();
    intervalId = setInterval(executeFunction, scheduleConfig.intervalMs);
    
    schedulerState.activeSchedules.set(scheduleId, {
      type: 'interval',
      intervalId,
      config: scheduleConfig,
      params,
      startTime: new Date(),
      executionCount: 1
    });
    
  } else if (scheduleConfig.type === 'times') {
    // Time-based scheduling
    const scheduleNextExecution = () => {
      const nextTime = getNextExecutionTime(scheduleConfig.times);
      const delay = nextTime.getTime() - Date.now();
      
      console.log(`⏰ Next execution scheduled for: ${nextTime.toISOString()}`);
      console.log(`⏳ Time until next execution: ${Math.round(delay / 1000)}s`);
      
      timeoutId = setTimeout(async () => {
        await executeFunction();
        
        // Update execution count
        const schedule = schedulerState.activeSchedules.get(scheduleId);
        if (schedule) {
          schedule.executionCount++;
          schedule.lastExecution = new Date();
        }
        
        // Schedule next execution
        scheduleNextExecution();
      }, delay);
      
      // Update schedule info
      const schedule = schedulerState.activeSchedules.get(scheduleId);
      if (schedule) {
        schedule.timeoutId = timeoutId;
        schedule.nextExecution = nextTime;
      }
    };
    
    schedulerState.activeSchedules.set(scheduleId, {
      type: 'times',
      config: scheduleConfig,
      params,
      startTime: new Date(),
      executionCount: 0
    });
    
    scheduleNextExecution();
  }
  
  return scheduleId;
}

/**
 * Stop a scheduled execution
 * @param {string} scheduleId - Schedule ID to stop
 * @returns {boolean} Success status
 */
function stopScheduledExecution(scheduleId) {
  const schedule = schedulerState.activeSchedules.get(scheduleId);
  
  if (!schedule) {
    console.log(`❌ Schedule ${scheduleId} not found`);
    return false;
  }
  
  if (schedule.intervalId) {
    clearInterval(schedule.intervalId);
  }
  
  if (schedule.timeoutId) {
    clearTimeout(schedule.timeoutId);
  }
  
  schedulerState.activeSchedules.delete(scheduleId);
  console.log(`🛑 Stopped scheduled execution: ${scheduleId}`);
  
  return true;
}

/**
 * Get status of all active schedules
 * @returns {Array} Array of schedule status objects
 */
function getScheduleStatus() {
  const statuses = [];
  
  for (const [scheduleId, schedule] of schedulerState.activeSchedules) {
    const status = {
      id: scheduleId,
      type: schedule.type,
      description: schedule.config.description,
      startTime: schedule.startTime,
      executionCount: schedule.executionCount,
      params: schedule.params
    };
    
    if (schedule.nextExecution) {
      status.nextExecution = schedule.nextExecution;
    }
    
    if (schedule.lastExecution) {
      status.lastExecution = schedule.lastExecution;
    }
    
    statuses.push(status);
  }
  
  return statuses;
}

// =============================
// ======= Baseline Function =======
// =============================

/**
 * Core baseline function that executes the trading logic
 * This is the internal function that performs the actual swap
 */
async function baselineFunctionCore(ownerAddress, fromToken, toToken, amount) {
  // Wallet Creation
  const wallet = await getOrCreateWallet(ownerAddress);
  console.log(wallet);
  
  // Get Balances
  const balances = await getBalances(wallet.walletAddress);
  console.log(balances);
    
  // Check if fromToken exists and get balance in one pass
  const fromTokenUpper = fromToken.toUpperCase();
  const tokenObj = balances.allBalances.find(
    token => token.symbol && token.symbol.toUpperCase() === fromTokenUpper
  );

  if (!tokenObj) {
    console.log(`Wallet does not have ${fromToken}`);
    return { success: false, error: `Wallet does not have ${fromToken}` };
  } else if (tokenObj.uiAmount >= amount) {
    console.log(`Sufficient ${fromToken} balance: ${tokenObj.uiAmount} (required: ${amount})`);

        const toTokenResult = await getTokenMintAddress(toToken);
        console.log('Token mint address result:', toTokenResult);
        
        if (!toTokenResult.success) {
            console.log(`Failed to get mint address for ${toToken}: ${toTokenResult.error}`);
            return { success: false, error: `Failed to get mint address for ${toToken}: ${toTokenResult.error}` };
        }
        
        const toTokenMintAddress = toTokenResult.mintAddress;
        console.log('To token mint address:', toTokenMintAddress);

        // Check if destination token account exists (affects rent requirements)
        const accountExists = await checkTokenAccountExists(wallet.walletAddress, toTokenMintAddress);
        console.log(`${toToken} account exists: ${accountExists}`);
        
        // Check SOL requirements (even if account exists, Jupiter may need wSOL account)
        const minRequiredSOL = 0.0021; // Minimum for any Jupiter swap (2.1 mSOL)
        if (tokenObj.uiAmount < minRequiredSOL) {
            console.log(`❌ Insufficient SOL for Jupiter swap operations`);
            console.log(`💰 Current: ${tokenObj.uiAmount} SOL`);
            console.log(`🎯 Required: ~${minRequiredSOL} SOL (for fees + potential wSOL account)`);
            console.log(`📈 Need: ${(minRequiredSOL - tokenObj.uiAmount).toFixed(6)} SOL more`);
            return { success: false, error: `Insufficient SOL for Jupiter swap operations. Need ${(minRequiredSOL - tokenObj.uiAmount).toFixed(6)} SOL more` };
        }
        
        if (!accountExists) {
            console.log(`⚠️  Note: First-time ${toToken} swap, but account already exists`);
        }

        // Execute optimized Jupiter swap with custom options
        console.log('Proceeding to execute optimized Jupiter swap...');
        const swapOptions = {
            slippageBps: 150, // 1.5% slippage tolerance
            priorityFee: 'auto',
            maxRetries: 2,
            confirmTransaction: true
        };
        const swapResult = await executeSwapJupiter(wallet.walletId, fromToken, toToken, amount, wallet.walletAddress, swapOptions);
        console.log('Optimized Jupiter swap result:', swapResult);
        return swapResult;
  } else {
    const errorMsg = `Insufficient ${fromToken} balance. Available: ${tokenObj.uiAmount}, required: ${amount}`;
    console.log(errorMsg);
    return { success: false, error: errorMsg };
  }
}

/**
 * Enhanced baseline function with optional scheduling support
 * @param {string} ownerAddress - Wallet owner address
 * @param {string} fromToken - Source token symbol
 * @param {string} toToken - Destination token symbol
 * @param {number} amount - Amount to swap
 * @param {Object} scheduleOptions - Optional scheduling configuration
 * @returns {Object} Execution result with schedule info if applicable
 */
async function baselineFunction(ownerAddress, fromToken, toToken, amount, scheduleOptions = null) {
  // If no scheduling options, execute immediately (backward compatibility)
  if (!scheduleOptions) {
    console.log('🚀 Executing baseline function immediately...');
    const result = await baselineFunctionCore(ownerAddress, fromToken, toToken, amount);
    return { 
      ...result,
      executionType: 'immediate',
      timestamp: new Date().toISOString()
    };
  }
  
  // Parse and validate schedule configuration
  const scheduleConfig = parseScheduleConfig(scheduleOptions.type, scheduleOptions.value);
  
  if (!scheduleConfig.isValid) {
    console.error('❌ Invalid schedule configuration');
    console.log('📝 Examples:');
    console.log('  Interval: "30m", "1h", "2h30m", "45s"');
    console.log('  Times: "09:30", "14:00,18:30", "9:30 AM,2:30 PM"');
    return { 
      success: false, 
      error: 'Invalid schedule configuration',
      examples: {
        interval: ['30m', '1h', '2h30m', '45s'],
        times: ['09:30', '14:00,18:30', '9:30 AM,2:30 PM']
      }
    };
  }
  
  // Start scheduled execution
  const scheduleId = startScheduledExecution(
    { ownerAddress, fromToken, toToken, amount },
    scheduleConfig
  );
  
  return {
    success: true,
    executionType: 'scheduled',
    scheduleId,
    scheduleDescription: scheduleConfig.description,
    timestamp: new Date().toISOString()
  };
}


// =============================
// ======= Utility Functions for User Interaction =======
// =============================

/**
 * Interactive function to get scheduling preferences from user
 * This would typically be called from a CLI or web interface
 */
function getSchedulingInput() {
  console.log('\n📅 Scheduling Options:');
  console.log('1. interval - Execute at regular intervals');
  console.log('2. times - Execute at specific times of day');
  console.log('3. immediate - Execute once now (no scheduling)');
  
  console.log('\n📝 Format Examples:');
  console.log('Interval formats: "30m", "1h", "2h30m", "45s"');
  console.log('Time formats: "09:30", "14:00,18:30", "9:30 AM,2:30 PM"');
  
  // In a real implementation, you would use readline or a web form
  // For now, this serves as documentation
  return {
    type: 'interval', // or 'times' or 'immediate'
    value: '30m' // or time string like "09:30,15:30"
  };
}

/**
 * Stop all active schedules
 */
function stopAllSchedules() {
  const activeScheduleIds = Array.from(schedulerState.activeSchedules.keys());
  let stoppedCount = 0;
  
  for (const scheduleId of activeScheduleIds) {
    if (stopScheduledExecution(scheduleId)) {
      stoppedCount++;
    }
  }
  
  console.log(`🛑 Stopped ${stoppedCount} active schedules`);
  return stoppedCount;
}

/**
 * Display current schedule status in a formatted way
 */
function displayScheduleStatus() {
  const statuses = getScheduleStatus();
  
  if (statuses.length === 0) {
    console.log('📋 No active schedules');
    return;
  }
  
  console.log('\n📋 Active Schedules:');
  console.log('==================');
  
  for (const status of statuses) {
    console.log(`\n🔹 ${status.id}`);
    console.log(`   Type: ${status.type}`);
    console.log(`   Description: ${status.description}`);
    console.log(`   Started: ${status.startTime.toISOString()}`);
    console.log(`   Executions: ${status.executionCount}`);
    console.log(`   Trading: ${status.params.amount} ${status.params.fromToken} → ${status.params.toToken}`);
    
    if (status.nextExecution) {
      console.log(`   Next: ${status.nextExecution.toISOString()}`);
    }
    
    if (status.lastExecution) {
      console.log(`   Last: ${status.lastExecution.toISOString()}`);
    }
  }
  console.log('');
}

// =============================
// ======= Example Usage =======
// =============================

// Example 1: Execute immediately (original behavior)
console.log('🚀 Example 1: Immediate execution');
// baselineFunction(ownerAddress, 'USDC', 'SOL', 0.01);

// Example 2: Schedule every 30 minutes
console.log('\n🕐 Example 2: Scheduled execution every 30 minutes');
// baselineFunction(ownerAddress, 'USDC', 'SOL', 0.01, {
//   type: 'interval',
//   value: '30m'
// });

// Example 3: Schedule at specific times
console.log('\n⏰ Example 3: Scheduled execution at specific times');
// baselineFunction(ownerAddress, 'USDC', 'SOL', 0.01, {
//   type: 'times',
//   value: '09:30,15:30,21:00'
// });

// Example 4: Schedule with AM/PM format
console.log('\n🌅 Example 4: Scheduled execution with AM/PM times');
// baselineFunction(ownerAddress, 'USDC', 'SOL', 0.01, {
//   type: 'times',
//   value: '9:30 AM,3:30 PM,9:00 PM'
// });

// Uncomment one of the examples above to test
// For now, run immediate execution
baselineFunction(ownerAddress, 'USDC', 'SOL', 0.01);

// Export functions for external use
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    baselineFunction,
    baselineFunctionCore,
    startScheduledExecution,
    stopScheduledExecution,
    stopAllSchedules,
    getScheduleStatus,
    displayScheduleStatus,
    parseScheduleConfig,
    getSchedulingInput,
    // Additional utility exports
    getOrCreateWallet,
    getBalances,
    transfer,
    swap,
    executeSwapJupiter,
    marketData,
    price,
    getTokenMintAddress,
    twitter
  };
}